
Route Tables: Determine how traffic is directed within the VPC and between the VPC and other networks.
Internet Gateway: Allows instances within the VPC to communicate with the internet.
Network ACLs and Security Groups: Provide network-level and instance-level security.
all service types defined with this

resource "aws_vpc" "main" {
  cidr_block = var.base_cidr_block
}

<BLOCK TYPE> "<BLOCK LABEL>" "<BLOCK LABEL>" {
  # Block body
  <IDENTIFIER> = <EXPRESSION> # Argument
}
--labeling the shit out of blocks
--most servcieces in blocks
--expressions are var most time


terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 1.0.4"
    }
  }
}

variable "aws_region" {}

variable "base_cidr_block" {
  description = "A /16 CIDR range definition, such as 10.1.0.0/16, that the VPC will use"
  default = "10.1.0.0/16"
}

variable "availability_zones" {
  description = "A list of availability zones in which to create subnets"
  type = list(string)
}

provider "aws" {
  region = var.aws_region
}

resource "aws_vpc" "main" {
  # Referencing the base_cidr_block variable allows the network address
  # to be changed without modifying the configuration.
  cidr_block = var.base_cidr_block
}

resource "aws_subnet" "az" {
  # Create one subnet for each given availability zone.
  count = length(var.availability_zones)

  # For each subnet, use one of the specified availability zones.
  availability_zone = var.availability_zones[count.index]

  # By referencing the aws_vpc.main object, OpenTofu knows that the subnet
  # must be created only after the VPC is created.
  vpc_id = aws_vpc.main.id

  # Built-in functions and operators can be used for simple transformations of
  # values, such as computing a subnet address. Here we create a /20 prefix for
  # each subnet, using consecutive addresses for each availability zone,
  # such as 10.1.16.0/20 .
#i think this f is adding 4 to the suffix route on the subnet ip, dont know how this would affect different availability zones
  cidr_block = cidrsubnet(aws_vpc.main.cidr_block, 4, count.index+1)
}



opentofu as routing table:
resource "aws_route_table" "public" {
  vpc_id = aws_vpc.main.id

  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.igw.id
  }

  route {
    cidr_block = "192.168.1.0/24"
    gateway_id = aws_vpn_gateway.vgw.id
  }
}

resource "aws_route_table_association" "public_subnet" {
  subnet_id      = aws_subnet.public.id
  route_table_id = aws_route_table.public.id
}

resource "aws_route_table" "private" {
  vpc_id = aws_vpc.main.id

  route {
    cidr_block = "192.168.1.0/24"
    gateway_id = aws_vpn_gateway.vgw.id
  }
}

resource "aws_route_table_association" "private_subnet_a" {
  subnet_id      = aws_subnet.private_a.id
  route_table_id = aws_route_table.private.id
}

resource "aws_route_table_association" "private_subnet_b" {
  subnet_id      = aws_subnet.private_b.id
  route_table_id = aws_route_table.private.id
}
commands:
opentofu init
opentofu plan
opentofu apply



Full walk:

Instance within a VPC
An instance is a virtual server running in the AWS cloud. When you launch an instance within a VPC, it gets assigned an IP address 
from one of the VPC's subnets.
Key Components of an Instance
* Private IP Address: Assigned from the subnet's CIDR block. Used for internal communication within the VPC.
* Public IP Address: (Optional) Assigned to enable communication with the internet.
* Elastic IP Address: (Optional) A static public IP address that can be associated with the instance.
* Security Groups: Act as a virtual firewall for the instance to control inbound and outbound traffic.
Example Scenario
1. VPC Configuration
Let's create a VPC with a CIDR block 10.0.0.0/16 and two subnets:
* Subnet A: 10.0.1.0/24
* Subnet B: 10.0.2.0/24
2. Instance Configuration
Launch an EC2 instance in Subnet A (10.0.1.0/24).
* Private IP Address: 10.0.1.10 (Assigned from Subnet A)
* Public IP Address: 52.12.34.56 (Assigned by AWS if the instance needs internet access)
* Security Group: Configured to allow inbound HTTP traffic (port 80) and outbound traffic.
3. Docker Container on the Instance
Deploy a Docker container running a web server (e.g., Nginx) on the instance.
* Instance Private IP Address: 10.0.1.10
* Container Internal IP Address: Typically assigned by Docker, e.g., 172.17.0.2
* Port Mapping: Map the container's port 80 to the instance's port 80.
Networking Flow
1. Instance Networking:
    * The instance 10.0.1.10 is part of Subnet A (10.0.1.0/24).
    * Subnet A routes traffic within the VPC and can route traffic to other subnets within the VPC (e.g., Subnet B 10.0.2.0/24).
    * If an Internet Gateway is attached to the VPC, the instance can communicate with the internet using its public IP address 
52.12.34.56.
2. Container Networking:
    * The Docker container runs inside the instance and has its internal IP address managed by Docker.
    * Port 80 on the container is mapped to port 80 on the instance, making the web server accessible via 10.0.1.10:80 (private IP) or 
52.12.34.56:80 (public IP).
Summary
* VPC: A virtual network in AWS with its own IP address range, subnets, routing tables, and gateways.
* Subnet: A subdivision of a VPC's IP address range, used to organize and isolate resources.
* Instance: A virtual server within a VPC, assigned an IP address from a subnet's CIDR block.
* Docker Container: Runs on the instance, with its own internal networking managed by Docker.
By understanding the roles of the VPC, subnets, instances, and Docker containers, you can effectively design and manage your cloud 
infrastructure, ensuring proper network segmentation, security, and connectivity for your applications.


This eventually goes to running replications of different hosts of instnaces with mutliple services on multiple ports 
that:

# OpenTofu configuration for VPC, subnet, and instances
provider "aws" {
  region = "us-west-2"
}

resource "aws_vpc" "main" {
  cidr_block = "192.168.0.0/16"
}

resource "aws_subnet" "main" {
  vpc_id     = aws_vpc.main.id
  cidr_block = "192.168.1.0/24"
}

resource "aws_instance" "web_server" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t2.micro"
  subnet_id     = aws_subnet.main.id

  tags = {
    Name = "WebServer"
  }

  network_interface {
    device_index = 0
    associate_public_ip_address = true
    private_ip = "192.168.1.10"
  }
}

resource "aws_instance" "database_server" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t2.micro"
  subnet_id     = aws_subnet.main.id

  tags = {
    Name = "DatabaseServer"
  }

  network_interface {
    device_index = 0
    associate_public_ip_address = true
    private_ip = "192.168.1.20"
  }
}

resource "aws_instance" "microservice" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t2.micro"
  subnet_id     = aws_subnet.main.id

  tags = {
    Name = "Microservice"
  }

  network_interface {
    device_index = 0
    associate_public_ip_address = true
    private_ip = "192.168.1.30"
  }
}

resource "aws_instance" "load_balancer" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t2.micro"
  subnet_id     = aws_subnet.main.id

  tags = {
    Name = "LoadBalancer"
  }

  network_interface {
    device_index = 0
    associate_public_ip_address = true
    private_ip = "192.168.1.40"
  }
}


version: '3'
services:
  app1:
    image: webserver:latest
    ports:
      - "80:8080"

  app2:
    image: webserver:latest
    ports:
      - "81:8081"

  app3:
    image: webserver:latest
    ports:
      - "82:8082"

  app4:
    image: webserver:latest
    ports:
      - "83:8083"

  app5:
    image: webserver:latest
    ports:
      - "84:8084"

  app6:
    image: webserver:latest
    ports:
      - "85:8085"

  app7:
    image: webserver:latest
    ports:
      - "86:8086"




version: '3'
services:
  app1:
    image: database:latest
    ports:
      - "3306:3306"

  app2:
    image: database:latest
    ports:
      - "3307:3307"

  app3:
    image: database:latest
    ports:
      - "3308:3308"

  app4:
    image: database:latest
    ports:
      - "3309:3309"

  app5:
    image: database:latest
    ports:
      - "3310:3310"

  app6:
    image: database:latest
    ports:
      - "3311:3311"

  app7:
    image: database:latest
    ports:
      - "3312:3312"


version: '3'
services:
  app1:
    image: microservice:latest
    ports:
      - "5000:5000"

  app2:
    image: microservice:latest
    ports:
      - "5001:5001"

  app3:
    image: microservice:latest
    ports:
      - "5002:5002"

  app4:
    image: microservice:latest
    ports:
      - "5003:5003"

  app5:
    image: microservice:latest
    ports:
      - "5004:5004"

  app6:
    image: microservice:latest
    ports:
      - "5005:5005"

  app7:
    image: microservice:latest
    ports:
      - "5006:5006"


version: '3'
services:
  app1:
    image: loadbalancer:latest
    ports:
      - "8080:8080"

  app2:
    image: loadbalancer:latest
    ports:
      - "8081:8081"

  app3:
    image: loadbalancer:latest
    ports:
      - "8082:8082"

  app4:
    image: loadbalancer:latest
    ports:
      - "8083:8083"

  app5:
    image: loadbalancer:latest
    ports:
      - "8084:8084"

  app6:
    image: loadbalancer:latest
    ports:
      - "8085:8085"

  app7:
    image: loadbalancer:latest
    ports:
      - "8086:8086"

